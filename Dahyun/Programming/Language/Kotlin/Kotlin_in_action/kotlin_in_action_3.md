---
sort: 3
---

# Kotlin In Action - Chapter_3 함수 정의와 호출

## 3.1 코틀린에서 컬렉션 만들기 

코틀린에서 컬렉션은 자바 컬렉션과 똑같다. 코틀린이 자체 컬렉션 기능을 제공하지 않는다는 이야기이다. 하지만 더 많은 기능을 쓸 수 있다.

마지막 원소나 최댓값 같은 녀석들을.

## 3.2 함수를 호출하기 쉽게 만들기

toString이 디폴트로 자바에 구현되어 있지만, 그게 필요한 형식이 아닐 수 있다.

자바에서는 구아바나 아파치 커먼즈 같은 서드파티 프로젝트를 추가하거나 로직을 구현해야 하지만, 코틀린은 이미 표준 라이브러리에 들어있다.

joinToString()이 바로 그것이다.

```kotlin
fun <T> joinToString(

collection : Collection<T>,

separator : String,

prefix: String,

postfix :String)

:String {...}
```

### 3.2.1 이름붙인 인자

자 여기서, 파라미터를 굳이 (list," "," "," ") 이렇게 하긴 좀 그렇다.

그럴 때, 코틀린에서는 joinToString(collection, separator = " ", prefix = " ", postfix = " ") 이런식으로 나타낼 수 있다. 

인자 중 하나라도 이름을 적었다면 그 뒤의 모든 인자는 꼭 이름을 명시해야한다.(혼동을 막기 위해서다)

자바는 이거 안된다!

### 3.2.2 디폴트 파라미터 값.

자바에서는 오버로딩한 메소드가 너무 많아진다는 문제가 있다. 8가지 생성자 등등...

코틀린에서는 이런 오버로드중 상당수를 피할 수 있다. 디폴트 값을 지정해주면 된다!

```kotlin
fun <T> joinToString(

collection: Collection<T>,

separator: String = "",

prefix: String="",

postfix :String="")

:String {...}
```

이런식으로 말이다! 이름 붙인 인자를 사용함으로써 필요한거만 쏙쏙 쓸 수 있다.

자바에서는 이게 안되는데 자바에서 코틀린 함수를 자주 호출해야 한다면,

@JvmOverloads를 사용하면 코틀린 컴파일러가 오버로드 메소드들을 자동으로 추가시켜 줄 수있다!

### 3.2.3 정적인 유틸리티 클래스 없애기. 

#### 3.2.3.1 최상위 함수

자바에선 모두 클래스의 메소드로 작성되어야한다. 그 결과 다양한 정적 메소드들을 모아두는 역할을 담당하는 인스턴스 메소드는 없는 클래스가 생성된다. 보통 Util이 이름에 들어있는 클래스를 찾으면 그렇다.

코틀린에서는 그럴 필요가 없다. 그냥 맨 밖에 두면 끝! 하지만 물론 그 파일에 속한다. 그래서 그 패키지를 임포트해야 쓸 수 있다. 그래도 클래스 이름을 쓸필요는 없다. 

근데 자바에서는 어떻게 코틀린 애들을 쓰지?

자동으로 클래스가 생성된다. 이름은 클래스이름+Kt이다. join.kt였으면 JoinKt.joinToString 이런 식이다!

@file:JvmName("newname")으로 최상위 함수가 속하는 클래스 이름을 바꿀 수 있다!

#### 3.2.3.2 최상위 프로퍼티

프로퍼티도 최상위 수준에 놓을 수 있다. var이든 val이든. val이라면 상수가 되겠지?

자바에서도 상수처럼 사용하고 싶다면? 그냥 하면 접근자 메소드를 써야하기 때문에 상수처럼 되는게 아니라 자연스럽지 못하다. 게터나 세터를 쓸 수 있으니. 

그럴 땐? const를 추가해서 const val로 하면 프로퍼티를 public static final 빌드로 컴파일하게 만들 수 있다.

## 3.3 메소드를 다른 클래스에 추가 : 확장 함수와 확장 프로퍼티

어떤 클래스 밖에 있음에도 불구하고, 그 클래스의 멤버 메소드인 것처럼 호출 가능한 함수.

사용법은 단순하다. 추가하려는 함수 이름 앞에 클래스 이름 붙여주면 된다. 인스턴스 객체를 this로 표현가능하고.

근데 이 this는 생략도 가능하다! 대신 protected나 private는 사용 불가능하다... 캡슐화를 깨지는 않는 것이다!

이 확장함수를 호출하는 쪽에서는 확장 함수와 멤버 메소드를 구분할 수도 없다. 그게 중요한 경우도 거의 없고

### 3.3.1 임포트와 확장 함수

임포트할 때 as 쓰면 클래스나 함수를 다른 이름으로 부를 수 있다. 이건 충돌을 막는 데 도움이 된다. 그리고 확장함수는 최상위함수는 아니기때문에 일반 함수처럼 임포트해야 쓸 수 있다.

자바에서는? 앞서 코틀린 애들 쓰던것처럼 

~~~java
char c = StringUtilKt.lastChar("Java");
~~~

이런식으로 쓰면 된다.

원래 내부적으로 확장함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드이다.

### 3.3.4 오버라이드

확장 함수는 오버라이드 할 수 없다. 정확히는 확장 함수는 클래스 밖에 선언된다.

정적 타입에 의해 결정되지, 동적 타입에 의해 결정되는게 아니라는 말이다. 

확장 함수를 첫 번째 인자가 수신 객체인 정적 자바 메소드로 컴파일 한다는 사실을 기억하면 쉽게 이해할 수 있다!

원래 자바 static은 컴파일 시점에 결정되고, 오버라이드는 런타임 시점에 결정되거든.

프로그래밍 언어 용어에서 정적이라는 말은 컴파일 시점을 의미하고, 

동적이라는 말은 실행 시점을 의미한다.

또한, 클래스를 확장한 함수와 원래 멤버함수의 이름과 시그니처가 같다면 멤버함수가 우선권을 가진다.

### 3.3.5 확장 프로퍼티

상태를 저장할 방법은 없다. 그런데 더 편할 경우가 있다.

실제로 상태는 없지만 편한 경우의 예시를 보자.

```kotlin
val String.lastChar : Char
    get() = get(length-1)
```
실제로 상태가 없다는 말이 뭔지 알 것이다. 참고로 바꿀 수 있으니 var도 가능하다.

```kotlin
var StringBuilder.lastChar: Char
    get() = get(length - 1) // get 이름 때문에 헷갈리진 말자, 이건 StringBuilder의 get.
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }
```

요런식으로 바꿀 수 있으니.

확장 프로퍼티를 사용하는 것도 멤버 프로퍼티를 쓰는 것과 같다.

물론 자바에서는? 코틀린 파일이름 써야겠지.

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

컬렉션을 처리할 때 쓸 수 있는 코틀린 표준 라이브러리 함수 몇가지가 잇다.

### 3.4.1 자바 컬렉션 API확장

자바의 라이브러리 클래스의 인스턴스인 컬렉션에 대해 어떻게 코틀린은 새로운 기능을 추가할 수 있었을까?

max()나 last() 같은 경우들!

앞서 배운 확장 함수가 그 답이었던 것이다.

### 3.4.2 인자의 개수가 달라질 수 있는 함수 정의.

내 기억에 c에서 printf도 그런 함수로 알고있는데...

아무튼 코틀린에서는 val list = listOf(2,3,5,7,11)

이런식으로 만들 수 있다.

~~~kotlin
fun listOf<T> (varang values : T) : List<T>{} // 이게 정의이다.
~~~

varang은 무엇인가. 원하는 갯수만큼 전달하는 것이다. 자바는 타입 뒤에 ...을 붙였다면 코틀린에서는 varang을 붙인다.

이미 배열에 들어있는 원소를 가변 인자로 넘기려면? 자바는 배열을 그냥 넘기면 되는데, 코틀린에서는 배열을 명시적으로 풀어 배열의 각 원소가 인자로 전달되게 해야한다. 

```kotlin
fun main(args : Array<String>){

val list = listOf("args: " , *args)

println(list)

} 
```

이런식으로! *를 스프레드 연산자라고 한다.

### 3.4.3 중위 호출

to라는 키워드. 이건 코틀린 키워드가 아니다. 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다. 중간에 집어넣는다는 뜻 같다!

만약 함수를 중위 호출시키게 허용하고 싶다면 infix 변경자를 함수 선언 앞에 추가해야한다.

~~~kotlin
infix fun Any.to(other:Any) = Pair(this,other)
~~~

이 to함수는 Pair의 인스턴스를 반환한다. 참고로 제네릭 함수이다(생략되었다)

~~~kotlin
val (number, name) = 1 to "one"
~~~

이런 식으로 가능하다. 이런 기능을 destructuring declaration - 구조 분해 선언이라 부른다. 복합적인 값을 여러값으로 그냥 넣는거다.

참고로 in withIndex 는 인덱스를 반복문에서 같이 주는거다.

## 3.5 문자열과 정규식 다루기

### 3.5.1 문자열 나누기

자바에서 split함수의 함정이 있다. "."으로 나눌 수 없기 때문이다. 그 이유는 split의 구분 문자열은 실제로 정규식이기 때문이다. 

"."은 와일드 카드로 해석될 수 있기 때문에 안되는 것이다.

그래서 코틀린은 명확히 하기 위해 정규식을 파라미터로 받는 함수를 실제로 Regex 타입의 값을 받게 한다.  

예를 들어, 12.345-6.A를 나누고 싶다면

~~~kotlin
println("12.345-6.A".split(\\.|-".toRegex()))
~~~

이런 식으로 만들어 줘야한다.

코틀린은 괜찮다. 


오버로딩한 버전 중에는 구분 문자열을 하나 이상 받는 함수가 있어서

~~~kotlin
println("12.345-6.A".split("-", "."))
~~~

이런식도 된다.

### 3.5.2 정규식과 3중 따옴표로 묶은 문자열

확장 함수를 이용해 파싱할 수도 있고, 정규식을 이용해 파싱할 수도 있다.

"""처럼 3중 따옴표를 쓰면 이스케이프를 안 써도 된다.

3중 따옴표는 줄바꿈도 그대로 들어간다는 점이 좋다. 테스트의 예상 출력을 작성할 때도 좋은 해법이 될 수 있다.

다만 문자열 템플릿을 표현하는 $는 넣을 수 없어 ${'$'}로 넣어야 한다.

## 3.6 코드 다듬기 : 로컬 함수의 확장

좋은 코드의 중요한 특징 중 하나는 중복의 제거이다.

DRY. Dont Repeat yourself

local함수로 깔끔하게 코드를 조직할 수 있다.

함수 안에 있는 함수라고 보면 되는데, 바깥 함수의 파라미터에 직접 접근이 가능하다. 그래서 중복을 줄일 수 있다.

바깥 함수의 모든 파라미터와 변수를 사용할 수 있다!

중첩의 깊이가 깊어지면 코드를 읽기 상당히 어려워진다. 따라서 한 단계만 중첩시키는게 좋다.
