---
sort: 2
---

# Kotlin In Action - Chapter_2 코틀린 기초

## 2.1 함수와 변수

### 2.1.1 함수의 특성

함수를 선언할 때 fun 키워드를 사용한다. fun한 일이다(외우기는 쉽네)

함수를 최상위 수준에 정의할 수 있다. 꼭 클래스 안에 넣을 필요가 없다.

자바처럼 배열 처리를 위한 문법이 따로 존재하지 않는다

system.out.printIn말고 printIn을 사용한다.여러가지 자바 라이브러리 함수를 간결하게 사용하도록 wrapper클래스를 사용한다. println이 그 중 하나다.

세미콜론 안 붙여도 된다.

### 2.1.2 함수

if가 값을 만들어내지 못하는 문장이 아니고 결과를 만들어내는 식이다.

TIP) 문(statement)와 식(expression)을 구분해야한다. 식은 값을 만들어내고 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재해야한다. 자바에서는 모든 제어구조가 문이고, 코틀린은 루프를 제외한 대부분의 제어 구조가 식이다. 

식이 본문인 함수와 블록이 본문인 함수로 나뉜다.

```kotlin
fun max(a: Int, b: Int):Int{
return if (a>b) a else b
}
fun max(a:Int,b:Int):Int = if(a>b) a else b
//아래가 식이 본문인 함수, 위가 블록이 본문인 함수이다.
```

여기서, 반환형도 생략할 수 있다. 정적 타입 언어로써 알아서 계산되니까. 

이 때, 식이 본문인 함수의 반환 타입만 생략 가능하다는 점.

### 2.1.3 변수

변경 불가능한 참조를 저장하는 변수 val, 이건 자바의 final 변수이고, (참조라는 것을 기억해라!)

변경 가능한 var. 이건 자바의 일반 변수이다.

기본적으로는 모든 변수를 val로 설정하고, 필요할 때만 var로 변경해야한다.

그러면 변경 불가능한 참조와 변경 불가능한 객체를 side effect가 없는 함수와 조합하면 함수형 프로그래밍에 가까워 질 수 있다!! val은 정확히 한 번만 초기화 되어야한다.

val 참조 자체는 불변이라도 그 참조가 가르키는 객체의 내부 값은 변경될 수 있다. 예를들면 val로 선언된 컬렉션에 add로 넣는 경우가 그런 경우일 것이다.

var은 값을 바꿀 수 있지만, 변수의 타입은 고정되어 바뀌지 않는다.

### 2.1.4 문자열 템플릿

잘 아는 string인데, $를 통해 문자열 템플릿을 사용할 수 있다.

```kotlin
val name = if (args.size>0) args[0] else "kotlin"
printIn("Hello $name!")
```

이런식으로! 만약 진짜 $를 쓰고싶다면 \$로 써야한다. 이걸 이스케이프(escape)라고 한다.

한글과 영문을 혼합해 사용하면 unresolved reference 에러를 발생시킬 수 있으니, 변수를 {}중괄호로 감싸는 습관을 들이는게 좋다!

## 2.2 클래스와 프로퍼티

```kotlin
    class Person(val name: String, var isMarried: Boolean)

    fun pr() {
        var person = Person("BoB", true)
        person.isMarried = false
    }
```

코틀린의 기본 가시성 변경자는 public이다. 따라서 디폴트값. 쓸 필요 없다. 새로 만들 때 new도 안 쓴다.

필드와 접근자를 묶어서 프로퍼티라고 한다. val은 접근자 게터가 있는 것이고, var은 접근자 게터와 세터가 둘 다 있는 것이다. 프로퍼티 이름을 호출하면 자동으로 게터를 호출해준다. 세터도 마찬가지로 호출된다.

is가 붙어있는 프로퍼티는 처리방식이 특이하다. 이름만 쓰고 get을 쓰지않는다. 세터에서는 is대신 set을 사용한다.(세터는 is를 없앤다고 보면 될듯) 아마 불린 값을 쓰기 때문에 그런게 아닌가 추측한다!

자바에서 isMarried, setMarried 접근자가 있다면 코틀린에선 isMarried가 프로퍼티의 이름인 것이다.

setName, getNmae의 접근자가 있으면? name이 있을 것이다!
​

### 2.2.1 커스텀 접근자

대부분의 프로퍼티에는 그 프로퍼티를 저장하기 위한 필드가 있는데, 이걸 backing field라고 한다. 

field를 직접 사용할 때만 생긴다. 접근해야하니까. 아니면 

~~~kotlin
val name = "nm"
    get() {
        return name
    }
~~~

이라고 했을 때,

name이 무한 get()되는 것이다. 그래서 field를 쓴다. 

~~~kotlin
val name = "nm"
    get() {
        return field
    }
~~~

이렇게!

~~~kotlin
var name = "nm"
    set(s) {
        field = "s"
    }
name = "ss"
println(name)
~~~

이렇게 하면 s가 출력되는걸 알면 된다.

근데 원한다면 다른 프로퍼티들을 통해 커스텀 게터를 작성하여 쓸 수도 있다.

어떤 것인가 하니, 

```kotlin
class Rectangle(val width: Int, val height: Int) {
    val isSquare: Boolean
        get() {
            return width == height
        }
    //get() = width == height 이랑 같다. 블록 안써도 됨
}
```

요런 식이다. 아래처럼 get을 바꿀 수도 있다.


### 2.2.1  코틀린 소스코드의 구조

패키지 단위로 관리된다. 모든 코틀린 파일의 맨 앞에 package 문을 넣을 수 있고, 그 파일 안의 모든 선언이 해당 패키지에 들어가게 된다. 

같은 패키지면 다른 파일에서 정의한 선언도 직접 사용할 수 있다. 그러나 다른 패키지에서 선언한 정의를 사용하려면 임포트를 통해 불러와야 한다. 파일의 맨 앞에 와야하는 것도 자바와 동일하다.

함수, 클래스, 모든 선언을 import로 가져올 수 있다. 최상위 함수는 그 이름을 써서 임포트할 수 있다.

*를 통해 그 패키지 안의 모든 선언을 임포트할 수 있지만, 최상위 함수나 프로퍼티도 다 가져온다는 점에 유의하자.

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 자바에서는 그게 안된다는걸 실험으로 확인한 적이 있던게 기억난다. 자바에선 디렉터리가 중요하다

그래서 디렉터리 없이 그냥 최상위 폴더에 kt파일만 넣어도 된다. 그래도 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다. 함께 사용하는 프로젝트가 있을 수도 있으니까.

## 2.3 enum, when

when은 switch랑 비슷하다.

소프트 키워드라는게 있다. enum은 class 앞에서는 특별한 의미를 가지게 되지만, 다른 곳에서는 이름으로 사용할 수도 있다. 반면, class는 그게 불가능하다. 키워드이기 때문이다.

아무튼 이 enum은 값만 열거하는건 아니다. 메소드나 프로퍼티를 정의할 수도 있다.

```kotlin
enum class Color(var r: Int, var g: Int, var b: Int) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    INDIGO(75, 0, 130),
    VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) * 256 + b
}
```

바이올렛 뒤의세미콜론에 주목해보자. 코틀린에서 다시 보게 될 줄은 몰랐다!

```kotlin
fun getMnemonic(color: Color) =
    when (color) {
        Color.RED -> "RICHARD"
        Color.ORANGE, Color.INDIGO -> "FEELGOOD"
        //...
        else -> "WOW"
    }
```

이제 when은 이런 식으로 사용 가능하다. 앞서 말했듯 when도 값을 만들어내는 식이다.

Color가 거추장스럽다면? enum 상수값들을 import 해주면 된다. 그냥 RED로 사용 가능하다.

when은 객체를 넣을수도 있다.

인자 없는 when도 있는데, 이러면 각 분기의 조건이 Boolean 식이어야 한다.

​
### 2.3.1 스마트 캐스트

is로 변수 타입을 검사한다. 그리고 자동으로 캐스팅해준다.

자바에서는 instanceof로 확인 후 명시적으로 변수 타입을 캐스팅해줘야했다.

이 때, 중요한 것은 든 값의 타입을 검사한 다음 그 값이 바뀔 수 없는 경우에만 작동한다는 것이다.

클래스의 프로퍼티에 접근한다고 했을 때, val이 아니거나, 커스텀 접근자를 썼으면 항상 같은 값을 내놓는다고 확신할 수 없기 때문이다.

명시적 캐스팅은 as로 한다.

### 2.3.7 if와 when의 분기에서 블록 사용

블록의 마지막 식이 블록의 결과라는 규칙은 블록이 값을 만들어내야 하는 경우 항상 성립한다.

하지만 이 규칙은 함수에 대해서는 성립하지 않는다.

## 2.4 while과 for

for i in 100 downTo 1 step 2 

downto는 내려간다는 건데 기본적으로 -1인 것이다. step으로 절댓값을 바꿔준다.

100, 98, 96 이런 식으로 내려간다.

1..100와 같은 범위를 이용한다. 3.4.3에서 더 자세히 다룬다.

in을 통해 범위 안에 속하는지도 체크해볼 수 있다.

~~~kotlin
fun lol() {
    val list = arrayListOf("00", "01", "10", "11")
    for ((index, item) in list.withIndex()) {
        println("${index}의 이진수 : $item")
    }
}
~~~
이건 약간 파이썬 느낌이 좀 난다.​

## 2.5 예외 처리

이 부분은 번역이 좀 애매한거 같다.

throw를 하는게 자바랑 똑같다.  try, catch, finally 를 똑같이 사용하되, 함수가 던질 수 있는 예외를 명시할 필요는 없다.

throws 절이 없다는 것이다. 자바에서는 checked exception를 강제하는데, 프로그래머들이 의미없이 예외를 던지거나, 잡되 처리하지는 않고 무시하는 코드가 흔한 경우가 많다. 

근데 코틀린은 checked, unchecked를 구별하지 않는다. 참고로 try도 식이다! 여러 문장이 있다면 마지막 문장을 반환한다!